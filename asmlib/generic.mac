%imacro alloca 1
	add esp, -%1
%endmacro

%imacro memset 3
	set	edi, %1
	set	eax, %2
	set	ecx, %3
	rep	stosb
	;out:
	; edi: %1 + %2
	; ecx: 0
	; eax: %3/0
%endmacro

%imacro memcpy 3
	set	edi, %1
	set	esi, %2
	set	ecx, %3
	rep	movsb
	;out:
	; edi: %1 + %3
	; esi: %2 + %3
	; ecx: 0
%endmacro

%macro doloop 1-2
	%ifid %2,push
		push ecx
		%push looppush
	%else
		%push loop
	%endif

	%if %1 == 0
		%fatal 0-time loops not supported
	%elif %1 == 1
		%define %$single 1
	%else
		%define %$single 0
	%endif

	set	ecx, %1
	%$loop:
%endmacro

%macro endloop 0
	%if %$single
		dec	ecx
	%else
		loop %$loop
	%endif

	%ifctx looppush
		pop ecx
		%pop looppush
	%else
		%pop loop
	%endif
%endmacro

%macro stos 1
	set eax, %1
	stosb
%endmacro

%define reg_fromzero 0
%define reg_keepflags 0
%define reg_stack 1
%define zero_seg 1
%imacro zero 1-*
	%rep %0
		regparse %1	
		%assign reg_track_type 2
		%assign reg_track_val 0
		;%if reg_fromzero == 1
		%if zero_seg || reg_keepflags
			mov	%1, fs
		%else
			xor	%1, %1
		%endif
	%rotate 1
	%endrep
%endmacro

%define reg_track_eax_val	-1
%define reg_track_ebx_val	-1
%define reg_track_eax_type	-1
%define reg_track_ebx_type	-1
%imacro regparse 1
	%defstr reg_str %1

	%substr reg_prefix reg_str 1,1
	%ifnidn reg_prefix,'e'
		%fatal 'set' with illegal register, %1, reg_prefix != 'e', pass __PASS__
	%endif

	%substr reg_id   reg_str 2,1
	%substr reg_type reg_str 3,1

	%defstr	reg_track_type2 %strcat("reg_track_",reg_str,"_type")
	%defstr	reg_track_val2  %strcat("reg_track_",reg_str,"_val")
	%xdefine	reg_track_type	reg_track_type2
	%xdefine	reg_track_val	reg_track_type2


	%ifidn reg_type,'x'
		%assign reg_var 1
		%strcat reg_low  reg_id "l"
		%strcat reg_high reg_id "h"
		%strcat reg_leg  reg_id "x"

		%deftok reg_low  reg_low
		%deftok reg_high reg_high
		%deftok reg_leg  reg_leg
	%else
		%assign reg_var 0
		%define reg_low  INVALID
		%define reg_high INVALID
		%define reg_leg  INVALID
	%endif

	%ifidn reg_str,'esp'
		%assign reg_notesp 0
	%else
		%assign reg_notesp 1
	%endif
%endmacro

%imacro int32 1
	%assign uint32 (+%1 % 0xFFFFFFFF)

	%if %1 > 0x7FFFFFFF
		%assign sint32 -(-%1 % 0xFFFFFFFF)
	%else
		%assign sint32 %1
	%endif

	;%warning %1 signed: sint32
	;%warning %1 unsigned: uint32
%endmacro

%imacro setfz 2
	regparse %1

	%ifnum %2
	int32 %2
	%else
	%assign sint32 0
	%assign uint32 0
	%endif

	%if %2 == 0
		%assign rsave rsave+5
						;0 bytes
	%elif %2 == 1 && !reg_keepflags
		%assign rsave rsave+4
		inc	%1			;1 byte
	%elif sint32 == -1 && !reg_keepflags
		%assign rsave rsave+4
		dec	%1			;1 byte
	%elif reg_var && uint32 < 256
		%assign rsave rsave+3
		mov	reg_low, %2		;2 bytes
	%elif reg_var && uint32 % 256 == 0 && uint32 >= 256 && uint32 < 65536
		%assign rsave rsave+3
		mov	reg_high, %2/256	;2 bytes
	%elif reg_var && sint32 < 0 && sint32 > -256 && !reg_keepflags
		%assign rsave rsave+2
		dec	%1
		mov	reg_low, (%2 & 0xFF)	;3 bytes
	; dec/mov reg_high 3b
	; mov reg_high/neg 4b
	; mov reg_low/bswap 4b
	; mov reg_high/bswap 4b
	; inc/ror1 3b
	; bts 4b
	%elif reg_notesp && sint32 < 128 && sint32 > -129
		%assign rsave rsave+2
		lea	%1, [%1+%2]		;3 bytes
	%elif sint32 < 128 && sint32 > -129 && reg_stack
		%assign rsave rsave+2
		push	%2
		pop	%1			;3 bytes
	%elif sint32 < 128 && sint32 > -129 && !reg_keepflags
		%assign rsave rsave+2
		add	%1, %2			;3 bytes
	%elif reg_var && uint32 < 65536
		%assign rsave rsave+1
		mov	reg_leg, %2		;4 bytes
	%elif !reg_notesp && sint32 < 128 && sint32 > -129
		%assign rsave rsave+1
		lea	%1, [%1+%2]		;4 bytes
	%else
		mov	%1, %2			;5 bytes
	%endif
%endmacro

%assign rsave 0

%imacro __set_num 2
	regparse %1
	;%warning blobb %1 %2
	int32 %2
	%assign fo ~%2

	%if %2 == 0
		%assign rsave rsave+3
		zero	%1	; 2 bytes
	%elif %2 == 1 && !reg_keepflags
		%assign rsave rsave+2
		zero	%1
		inc	%1	; 3 bytes
	%elif sint32 == -1 && !reg_keepflags
		%assign rsave rsave+2
		zero	%1
		dec	%1	; 3 bytes
	%elif sint32 < 128 && sint32 > -129 && reg_stack
		%assign rsave rsave+2
		push	%2
		pop	%1	; 3 bytes
	%elif reg_var && uint32 < 256
		%assign rsave rsave+1
		zero	%1	; 4 bytes
		mov	reg_low, %2	
	%elif reg_var && uint32 % 256 == 0 && uint32 >= 256 && uint32 < 65536
		%assign rsave rsave+1
		zero	%1	; 4 bytes
		mov	reg_high, %2/256
	%elif reg_var && %2 == 0xFFFF && !reg_keepflags
		%assign rsave rsave+1
		zero	%1	; 4 bytes
		dec	reg_leg
	%else
		mov	%1, %2	; 5 bytes
	%endif

	%assign %tok(reg_track_type) 1
	%assign %tok(reg_track_val) %2
%endmacro

%imacro set 2
	;%warning set __FILE__:__LINE__, %0 %1 %2 foo low, fo, pass __PASS__

	; goddamn nasm devs... $ and $$ are "else", but so are unevaluated expressions
	%ifidn %2,$
		mov	%1, %2	; 5 bytes
	%elifidn %2,$$
		mov	%1, %2	; 5 bytes
	%elifid %2
		%if %1 == %2
		; nothing
		%else
		mov	%1, %2	; 2 bytes
		%endif
	%elifnum %2
		__set_num %1, %2
	%elifstr %2
		__set_num %1, %2
	%else
		%warning NOT NUM __FILE__:__LINE__, %0 %1 %2 reg_high reg_low, pass __PASS__
		__set_num %1, %2
		;mov	%1, %2	; 5 bytes
	%endif
%endmacro

%imacro set2n 2
%endmacro
